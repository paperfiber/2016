#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           feeder,        tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           LUflywheel,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LDflywheel,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LBdrive,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           LFdrive,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           RBdrive,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RFdrive,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           RDflywheel,    tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           RUflywheel,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          intake1,       tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
int motorSpeed = 0;
float velocity;
float flywheelSetpoint = 400;
float flywheelSpeed;
float flywheelKp = .01;
int position1;
int position2;

task flywheelVelocity(){
	while(true){
		position1 = nMotorEncoder(RDflywheel);
		wait1Msec(200);
		position2 = nMotorEncoder(RDflywheel);
		wait1Msec(200);
		velocity = (position2 - position1)/4*10;
	}
}

task flywheelP(){
	float error;

	startTask(flywheelVelocity);

	while(true){

		error = flywheelSetpoint - velocity;
		flywheelSpeed += (flywheelKp*error);

		if(flywheelSpeed > 127)
			flywheelSpeed = 127;
		else if (flywheelSpeed < 0)
			flywheelSpeed = 0;

		motor[LDflywheel] = flywheelSpeed;
		motor[LUflywheel] = flywheelSpeed;
		motor[RDflywheel] = flywheelSpeed;
		motor[RUflywheel] = flywheelSpeed;
		wait1Msec(30);
	}
}

void speedUpFlywheel(){
	while(motorSpeed < 90){
		if(motorSpeed < 90)
			motorSpeed += 2;
		else
			motorSpeed = 90;

		motor[LUflywheel] = motorSpeed;
		motor[LDflywheel] = motorSpeed;
		motor[RUflywheel] = motorSpeed;
		motor[RUflywheel] = motorSpeed;

		wait1Msec(250);
	}
	//startTask(flywheelP);
}


void slowDownFlywheel(){
	if(motorSpeed > 0)
		motorSpeed -= 2;
	else
		motorSpeed = 0;

	motor[LUflywheel] = motorSpeed;
	motor[LDflywheel] = motorSpeed;
	motor[RUflywheel] = motorSpeed;
	motor[RDflywheel] = motorSpeed;

	wait1Msec(250);
}

/*task shooter(){
while(true){
if(vexRT(Btn6U)){
while(!vexRT(Btn6D))
speedUpFlywheel();
}
else if(vexRT(Btn6D)){
while(!vexRT(Btn6U))
slowDownFlywheel();
}
}*/


task drive(){
	while(true){
		motor[LFdrive] = vexRT(Ch3);
		motor[LBdrive] = vexRT(Ch3);
		motor[RFdrive] = vexRT(Ch2);
		motor[RBdrive] = vexRT(Ch2);
		wait1Msec(25);
	}
}

task intake(){
	while(true){
		if(vexRT(Btn5U)){
			motor[intake1] = 127;

		}
		else if(vexRT(Btn5D)){
			motor[feeder] = 90;
		}
		else{
			motor[intake1] = 0;
			motor[feeder] = 0;
		}
		wait1Msec(25);
	}
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
}


task autonomous()
{
	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

task usercontrol()
{
//	startTask(shooter);
	startTask(drive);
	startTask(intake);
	startTask(flywheelVelocity);
	speedUpFlywheel();

	while(true){ /*
		if(vexRT(Btn8U)){
			motor[LUflywheel] = 127;
			motor[LDflywheel] = 127;
			motor[RUflywheel] = 127;
			motor[RDflywheel] = 127;
		}
		else if(vexRT(Btn8D)){
			motor[LDflywheel] = 100;
			motor[RUflywheel] = 100;
			motor[RDflywheel] = 100;
		}
		*/

		if(vexRT(Btn8L))
			slowDownFlywheel();
		wait1Msec(25);
	}
}
