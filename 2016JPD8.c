#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           feeder,        tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           LUflywheel,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LDflywheel,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LBdrive,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           LFdrive,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           RBdrive,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RFdrive,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           RDflywheel,    tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           RUflywheel,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          intake1,       tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
int motorSpeed = 0;
/*
int velocity;
int position1;
int position2;

task flywheelVelocity(){

while(true){

position1 = nMotorEncoder(lrFlywheel);
wait1Msec(200);
position2 = nMotorEncoder(lrFlywheel);
wait1Msec(200);
velocity = (position2 - position1)/4;

	}
}*/
float pidRequestedValue = 1000;

task maintainFlywheel () {

	int targetVelocity;

	float Kp = 2.0;
	float Ki = 0.04;
	float Kd = 0;

	float pidError;
	float pidLastError;
	float pidIntegral;
	float pidDerivative;
	float pidDrive;
	float pidSensorCurrentValue;

	pidLastError = 0;
	pidIntegral = 0;

	nMotorEncoder(RDflywheel) = 0;

	while(true) {
		pidSensorCurrentValue - pidRequestedValue;

		//Integral
		if(Ki != 0) {
			if(abs(pidError) < 50)
				pidIntegral = pidIntegral + pidError;
			else
				pidIntegral = 0;
		}
		else
			pidIntegral  = 0;

		//calculate derivative
		pidDerivative = pidError - pidLastError;
		pidLastError = pidError;

		pidDrive = (Kp * pidError) + (Ki * pidIntegral) + (Kd* pidDerivative);

		//limits
		if(pidDrive > 127)
			pidDrive = 127;
		if(pidDrive < -127)
			pidDrive = 127;

			int motorSpeed = pidDrive *
			motor[RDflywheel] = pidDrive * pidMotorScale;



	}
}
void speedUpFlywheel(){
	while(motorSpeed < 90){
		if(motorSpeed < 90)
			motorSpeed += 2;
		else
			motorSpeed = 90;

		motor[LUflywheel] = motorSpeed;
		motor[LDflywheel] = motorSpeed;
		motor[RUflywheel] = motorSpeed;
		motor[RUflywheel] = motorSpeed;

		wait1Msec(250);
	}
}


void slowDownFlywheel(){
	if(motorSpeed > 0)
		motorSpeed -= 2;
	else
		motorSpeed = 0;

	motor[LUflywheel] = motorSpeed;
	motor[LDflywheel] = motorSpeed;
	motor[RUflywheel] = motorSpeed;
	motor[RDflywheel] = motorSpeed;

	wait1Msec(250);
}

/*task shooter(){
while(true){
if(vexRT(Btn6U)){
while(!vexRT(Btn6D))
speedUpFlywheel();
}
else if(vexRT(Btn6D)){
while(!vexRT(Btn6U))
slowDownFlywheel();
}
}*/


task drive(){
	while(true){
		motor[LFdrive] = vexRT(Ch3);
		motor[LBdrive] = vexRT(Ch3);
		motor[RFdrive] = vexRT(Ch2);
		motor[RBdrive] = vexRT(Ch2);
		wait1Msec(25);
	}
}

task intake(){
	while(true){
		if(vexRT(Btn5U)){
			motor[intake1] = 127;

		}
		else if(vexRT(Btn5D)){
			motor[feeder] = 90;
		}
		else{
			motor[intake1] = 0;
			motor[feeder] = 0;
		}
		wait1Msec(25);
	}
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
}


task autonomous()
{
	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

task usercontrol()
{
//	startTask(shooter);
	startTask(drive);
	startTask(intake);
	speedUpFlywheel();
	while(true){
		if(vexRT(Btn8U)){
			motor[LUflywheel] = 127;
			motor[LDflywheel] = 127;
			motor[RUflywheel] = 127;
			motor[RDflywheel] = 127;
		}
		else if(vexRT(Btn8D)){
			motor[LDflywheel] = 100;
			motor[RUflywheel] = 100;
			motor[RDflywheel] = 100;
		}
		else if(vexRT(Btn8L))
			slowDownFlywheel();
		wait1Msec(25);
	}


}
