#pragma config(Motor,  port1,           feeder,        tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           LUflywheel,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LDflywheel,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LBdrive,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LFdrive,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RBdrive,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           RFdrive,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           RDflywheel,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           RUflywheel,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          intake1,       tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
int motorSpeed = 0;
/*
int velocity;
int position1;
int position2;

task flywheelVelocity(){

while(true){

position1 = nMotorEncoder(lrFlywheel);
wait1Msec(200);
position2 = nMotorEncoder(lrFlywheel);
wait1Msec(200);
velocity = (position2 - position1)/4;

}
}*/




void speedUpFlywheel(){
	while(motorSpeed < 90){
		if(motorSpeed < 90)
			motorSpeed += 2;
		else
			motorSpeed = 90;

		motor[LUflywheel] = motorSpeed;
		motor[LDflywheel] = motorSpeed;
		motor[RUflywheel] = motorSpeed;
		motor[RUflywheel] = motorSpeed;

		wait1Msec(250);
	}
}


void slowDownFlywheel(){
	if(motorSpeed > 0)
		motorSpeed -= 2;
	else
		motorSpeed = 0;

	motor[LUflywheel] = motorSpeed;
	motor[LDflywheel] = motorSpeed;
	motor[RUflywheel] = motorSpeed;
	motor[RDflywheel] = motorSpeed;

	wait1Msec(250);
}

/*task shooter(){
while(true){
if(vexRT(Btn6U)){
while(!vexRT(Btn6D))
speedUpFlywheel();
}
else if(vexRT(Btn6D)){
while(!vexRT(Btn6U))
slowDownFlywheel();
}
}*/


task drive(){
	while(true){
		motor[LFdrive] = vexRT(Ch3);
		motor[LBdrive] = vexRT(Ch3);
		motor[RFdrive] = vexRT(Ch2);
		motor[RBdrive] = vexRT(Ch2);
		wait1Msec(25);
	}
}

task intake(){
	while(true){
		if(vexRT(Btn5U)){
			motor[intake1] = 127;

		}
		else if(vexRT(Btn5D)){
			motor[feeder] = 90;
		}
		else{
			motor[intake1] = 0;
			motor[feeder] = 0;
		}
		wait1Msec(25);
	}
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
}


task autonomous()
{
	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

task usercontrol()
{
//	startTask(shooter);
	startTask(drive);
	startTask(intake);
	speedUpFlywheel();
	while(true){
		if(vexRT(Btn8U)){
			motor[LUflywheel] = 127;
			motor[LDflywheel] = 127;
			motor[RUflywheel] = 127;
			motor[RDflywheel] = 127;
		}
		else if(vexRT(Btn8D)){
			motor[LDflywheel] = 100;
			motor[RUflywheel] = 100;
			motor[RDflywheel] = 100;
		}
		else if(vexRT(Btn8L))
			slowDownFlywheel();
		wait1Msec(25);
	}


}
